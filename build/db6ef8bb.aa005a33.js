(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{87:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return d}));var a=t(2),o=t(6),r=(t(0),t(93)),i=["components"],l={id:"performance-optimizations",title:"Performance optimizations"},c={unversionedId:"performance-optimizations",id:"performance-optimizations",isDocsHomePage:!1,title:"Performance optimizations",description:"Lazy evaluation",source:"@site/main/docs/performance-optimizations.md",slug:"/performance-optimizations",permalink:"/docs/performance-optimizations",editUrl:"https://github.com/xoidlabs/xoid/blob/main/docs/performance-optimizations.md",version:"current",sidebar:"docs",previous:{title:"Quick Tutorial",permalink:"/docs/quick-tutorial"},next:{title:"Streams",permalink:"/docs/streams"}},s=[{value:"Lazy evaluation",id:"lazy-evaluation",children:[]},{value:"Lazy evaluation in derived atoms",id:"lazy-evaluation-in-derived-atoms",children:[]},{value:"Dependency collection in derived atoms",id:"dependency-collection-in-derived-atoms",children:[]},{value:"Lazy evaluation in atoms created with <code>.map</code> method",id:"lazy-evaluation-in-atoms-created-with-map-method",children:[]}],u={rightToc:s},p="wrapper";function d(e){var n=e.components,t=Object(o.a)(e,i);return Object(r.b)(p,Object(a.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"lazy-evaluation"},"Lazy evaluation"),Object(r.b)("p",null,"Atoms are lazily evaluated. If an atom is created using a ",Object(r.b)("em",{parentName:"p"},"state initializer function"),", this function won't run until the ",Object(r.b)("inlineCode",{parentName:"p"},".value")," getter is read, or the atom is subscribed for the first time."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"const $atom = create(() => {\n  console.log('I am lazily evaluated!')\n  return expensiveComputation(25)\n})\n// nothing's logged on the console yet\n\nconsole.log($atom.value)\n// Console: \"I am lazily evaluated!\"\n// Console: 25\n\nconsole.log($atom.value)\n// Console: 25\n")),Object(r.b)("p",null,"You can make use of this feature to avoid expensive computations where possible."),Object(r.b)("h2",{id:"lazy-evaluation-in-derived-atoms"},"Lazy evaluation in derived atoms"),Object(r.b)("p",null,"A derived atom is not much different than a classical atom. Still, its state initializer function will wait for the atom's value to be requested in order to run. "),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"const $alpha = create(3)\nconst $beta = create(5)\n\nconst $sum = create((read) => {\n  console.log('Evaluation occured')\n  return read($alpha) + read($beta)\n})\n// nothing's logged on the console yet\n")),Object(r.b)("p",null,"Later, when it's consumed for the first time:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},'console.log($sum.value)\n// Console: "Evaluation occured"\n// Console: 8\n\nconsole.log($sum.value)\n// Console: 8\n')),Object(r.b)("h2",{id:"dependency-collection-in-derived-atoms"},"Dependency collection in derived atoms"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Dependency collection")," is another performance optimization that makes lazy evaluation much more advanced.\nWhen an atom is evaluated, it collects its latest dependencies. Since the ",Object(r.b)("inlineCode",{parentName:"p"},"$sum")," is evaluated at least once in our previous example, it's now \"aware\" that it's dependencies are ",Object(r.b)("inlineCode",{parentName:"p"},"$alpha")," and ",Object(r.b)("inlineCode",{parentName:"p"},"$beta"),". Let's observe what will happen when those dependencies are updated:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},'$alpha.set(30)\n$alpha.update((s) => s + 1)\n$beta.set(1000)\n// nothing\'s logged on the console yet\n\nconsole.log($sum.value)\n// Console: "Evaluation occured"\n// Console: 1031\n\nconsole.log($sum.value)\n// Console: 1031\n')),Object(r.b)("p",null,"Observe that ",Object(r.b)("inlineCode",{parentName:"p"},"$sum")," knew that it needs to rerun its state initializer when it's ",Object(r.b)("inlineCode",{parentName:"p"},".value")," is requested after the dependencies are changed. This can happen thanks to ",Object(r.b)("strong",{parentName:"p"},"dependency collection"),". ",Object(r.b)("inlineCode",{parentName:"p"},"$sum")," knows that its internal state is invalid without causing evaluation. It can avoid evaluation until it's essential."),Object(r.b)("h2",{id:"lazy-evaluation-in-atoms-created-with-map-method"},"Lazy evaluation in atoms created with ",Object(r.b)("inlineCode",{parentName:"h2"},".map")," method"),Object(r.b)("p",null,"Same kind of performance optimizations apply to the atoms that are created using the ",Object(r.b)("inlineCode",{parentName:"p"},".map")," method."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"const $count = create(() => {\n  console.log('Ancestor atom evaluated')\n  return 100\n})\n\nconst $doubleCount = $count.map((value) => {\n  console.log('Evaluation occured')\n  return value * 2\n})\n// nothing's logged on the console yet\n\n$count.update(s => s + 1)\n// Console: \"Ancestor atom evaluated\"\n\nconsole.log($doubleCount.value)\n// Console: \"Evaluation occured\"\n// Console: 202\n\nconsole.log($doubleCount.value)\n// Console: 202\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("strong",{parentName:"p"},"xoid"),' supports special kind of atoms called "stream"s.\nA stream is "an atom that may or may not have an immediate value". Lazy evaluation works slightly different in a "stream". See the ',Object(r.b)("a",{parentName:"p",href:"streams"},"next section")," for more.")))}d.isMDXComponent=!0},93:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return v}));var a=t(0),o=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=o.a.createContext({}),u=function(e){var n=o.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=u(e.components);return o.a.createElement(s.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},b=o.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=u(t),d=a,b=p["".concat(i,".").concat(d)]||p[d]||m[d]||r;return t?o.a.createElement(b,l(l({ref:n},s),{},{components:t})):o.a.createElement(b,l({ref:n},s))}));function v(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=b;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[d]="string"==typeof e?e:a,i[1]=l;for(var s=2;s<r;s++)i[s]=t[s];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"}}]);