"use strict";(self.webpackChunkxoid_website=self.webpackChunkxoid_website||[]).push([[736],{784:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var n=s(5893),i=s(1151);const r={id:"nested-state",title:"Working with nested state"},o=void 0,d={id:"recipes/nested-state",title:"Working with nested state",description:"Before xoid:",source:"@site/main/docs/recipes/nested-state.md",sourceDirName:"recipes",slug:"/recipes/nested-state",permalink:"/docs/recipes/nested-state",draft:!1,unlisted:!1,editUrl:"https://github.com/xoidlabs/xoid/blob/main/docs/recipes/nested-state.md",tags:[],version:"current",lastUpdatedAt:1696936626,formattedLastUpdatedAt:"Oct 10, 2023",frontMatter:{id:"nested-state",title:"Working with nested state"},sidebar:"docs",previous:{title:"Grabbing refs",permalink:"/docs/recipes-react/grabbing-refs"},next:{title:"Using immer",permalink:"/docs/recipes/using-immer"}},a={},l=[{value:"Related",id:"related",level:3}];function c(e){const t={a:"a",code:"code",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["Before ",(0,n.jsx)(t.strong,{children:"xoid"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"setState((state) =>  {\n  ...state, \n  deeply: {\n    ...state.deeply,\n    nested: {\n      ...state.deeply.nested,\n      value: state.deeply.nested.value + 1\n    }\n  }\n})\n"})}),"\n",(0,n.jsxs)(t.p,{children:["After ",(0,n.jsx)(t.strong,{children:"xoid"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"atom.focus(s => s.deeply.nested.value).update(s => s + 1)\n"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"xoid"})," makes it easier to work with nested state. Redux and React (and ",(0,n.jsx)(t.strong,{children:"xoid"}),") are  based on immutable updates. Immutability is great, however it usually has a bad impact on code readability."]}),"\n",(0,n.jsxs)(t.p,{children:["To overcome this, there are other tools like ",(0,n.jsx)(t.strong,{children:"immutablejs"})," or ",(0,n.jsx)(t.strong,{children:"immer"}),". Even Redux Toolkit comes with ",(0,n.jsx)(t.strong,{children:"immer"})," by default. Note that using Redux toolkit means adding another ~11kB to your bundle size. This number is ~5kB for ",(0,n.jsx)(t.strong,{children:"immer"})," alone. ",(0,n.jsx)(t.strong,{children:"xoid"})," is ~1kB, yet it can be used to overcome the same problem."]}),"\n",(0,n.jsx)(t.h3,{id:"related",children:"Related"}),"\n",(0,n.jsxs)(t.p,{children:["To see how ",(0,n.jsx)(t.strong,{children:"xoid"})," compares to a classical reducer, and a dedicated library that's using ",(0,n.jsx)(t.strong,{children:"immer"})," internally (",(0,n.jsx)(t.code,{children:"use-methods"}),"), you can check the following example:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/xoidlabs/xoid/tree/master/examples/xoid-vs-usereducer-vs-usemethods",children:"xoid vs useReducer vs useMethods"})," ",(0,n.jsx)(t.a,{href:"https://githubbox.com/xoidlabs/xoid/tree/master/examples/xoid-vs-usereducer-vs-usemethods",children:(0,n.jsx)(t.img,{src:"https://img.shields.io/badge/Open%20in-CodeSandbox-blue?style=flat&colorA=4f2eb3&colorB=4f2eb3&logo=codesandbox",alt:"Open in CodeSandbox"})})]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>d,a:()=>o});var n=s(7294);const i={},r=n.createContext(i);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);