"use strict";(self.webpackChunkxoid_website=self.webpackChunkxoid_website||[]).push([[447],{4714:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var s=t(5893),c=t(1151);const r={id:"dynamic-functions-with-fixed-references",title:"Dynamic functions with fixed references"},i=void 0,o={id:"recipes-react/dynamic-functions-with-fixed-references",title:"Dynamic functions with fixed references",description:"Inside a React function component, in some cases a function with a fixed reference, but a dynamic content may be needed. While this is not as straightforward with React, it is with xoid*.",source:"@site/main/docs/recipes-react/dynamic-functions-with-fixed-references.md",sourceDirName:"recipes-react",slug:"/recipes-react/dynamic-functions-with-fixed-references",permalink:"/docs/recipes-react/dynamic-functions-with-fixed-references",draft:!1,unlisted:!1,editUrl:"https://github.com/xoidlabs/xoid/blob/main/docs/recipes-react/dynamic-functions-with-fixed-references.md",tags:[],version:"current",lastUpdatedAt:1696460720,formattedLastUpdatedAt:"Oct 4, 2023",frontMatter:{id:"dynamic-functions-with-fixed-references",title:"Dynamic functions with fixed references"},sidebar:"docs",previous:{title:"Creating React custom hooks",permalink:"/docs/recipes-react/creating-react-custom-hooks"},next:{title:"Refactoring React classes",permalink:"/docs/recipes-react/refactoring-react-classes"}},a={},d=[{value:"Quick Example",id:"quick-example",level:3},{value:"Another Example",id:"another-example",level:3}];function l(e){const n={blockquote:"blockquote",code:"code",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,c.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Inside a React function component, in some cases ",(0,s.jsx)(n.strong,{children:"a function with a fixed reference, but a dynamic content"})," may be needed. While this is not as straightforward with React*, it is with ",(0,s.jsx)(n.strong,{children:"xoid"}),"."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["*: Since this recipe was written, ",(0,s.jsx)(n.code,{children:"useEvent"}),' "the missing hook" has been added to React to solve the same problem. However ergonomicity claims of ',(0,s.jsx)(n.strong,{children:"xoid"})," still hold."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"quick-example",children:"Quick Example"}),"\n",(0,s.jsxs)(n.p,{children:["Let's imagine, we have the following ",(0,s.jsx)(n.code,{children:"React.useEffect"}),". Inside it, an event listener is attached and removed everytime when ",(0,s.jsx)(n.code,{children:"props.number"})," changes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"useEffect(() => {\n  const callback = () => console.log(props.number)\n  window.addEventListener('click', callback)\n  return () => window.removeEventListener('click', callback)\n}, [props.number])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's assume that, due to changed app requirements, we want to attach the listener only once, and remove it once the component is unmounted. This can be achieved in React way as the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// a ref to keep the value\nconst numberRef = useRef(props.number)\n// an effect to update ref's current value when the `props.number` is changed\nuseEffect(() => (numberRef.current = props.number), [props.number])\n\n// This time useEffect is with an empty dependency array, and it references the ref.\nuseEffect(() => {\n  const callback = () => console.log(numberRef.current)\n  window.addEventListener('click', callback)\n  return () => window.removeEventListener('click', callback)\n}, [])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["With ",(0,s.jsx)(n.strong,{children:"xoid"}),", the equivalent optimization is simply the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"useSetup(($props, { effect }) => {\n  effect(() => {\n    const callback = () => console.log($props.value.number)\n    window.addEventListener('click', callback)\n    return () => window.removeEventListener('click', callback)\n  })\n}, props)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After getting used to, ",(0,s.jsx)(n.strong,{children:"xoid"})," can feel more intuitive than React hooks in a lot of cases."]}),"\n",(0,s.jsx)(n.h3,{id:"another-example",children:"Another Example"}),"\n",(0,s.jsx)(n.p,{children:"Let's propose another problem, this time let's examine it in a more concrete scenario."}),"\n",(0,s.jsxs)(n.p,{children:["Let's imagine, inside a React component, we're supposed to initialize a class called ",(0,s.jsx)(n.code,{children:"DragDropLibrary"})," ",(0,s.jsx)(n.strong,{children:"only once"})," as ",(0,s.jsx)(n.code,{children:"new DragDropLibrary({ onDrop })"}),". Let's assume we have only one chance to supply ",(0,s.jsx)(n.code,{children:"onDrop"})," to the class instance, and this function cannot be replaced afterwards."]}),"\n",(0,s.jsxs)(n.p,{children:["Imagine that ",(0,s.jsx)(n.code,{children:"props.func"})," is our dynamic function that changes in every render, and we're supposed to feed it to ",(0,s.jsx)(n.code,{children:"onDrop"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["With ",(0,s.jsx)(n.strong,{children:"xoid"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"useSetup(($props) => {\n  const onDrop = (...args) => $props.value.func(...args)\n  new DragDropLibrary({ onDrop })\n}, props)\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Think of ",(0,s.jsx)(n.code,{children:"useSetup"})," as not a hook, but as something unchanging, some closure that does not ever rerender. ",(0,s.jsx)(n.strong,{children:"@xoid/react"}),", in some sense, is a React without hooks."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Without ",(0,s.jsx)(n.strong,{children:"xoid"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const funcRef = useRef((...args) => props.func(...args))\nuseEffect(() => { funcRef.current = (...args) => props.func(...args) }, [props.func])\nuseMemo(() => {\n  new DragDropLibrary({ onDrop: funcRef.current })\n}, [])\n"})})]})}function h(e={}){const{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>i});var s=t(7294);const c={},r=s.createContext(c);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);