"use strict";(self.webpackChunkxoid_website=self.webpackChunkxoid_website||[]).push([[432],{4982:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var s=t(5893),a=t(1151);const r={id:"streams",title:"Streams"},o=void 0,i={id:"streams",title:"Streams",description:"xoid offers basic support for streams. Streams are generally treated as a whole different concept than atoms. They're actually very close, and there's no need for a completely different library for them. xoid thinks that streams can easily be a a \"bonus feature\" of an atomic state management library.",source:"@site/main/docs/streams.md",sourceDirName:".",slug:"/streams",permalink:"/docs/streams",draft:!1,unlisted:!1,editUrl:"https://github.com/xoidlabs/xoid/blob/main/docs/streams.md",tags:[],version:"current",lastUpdatedAt:1696460720,formattedLastUpdatedAt:"Oct 4, 2023",frontMatter:{id:"streams",title:"Streams"},sidebar:"docs",previous:{title:"Performance optimizations",permalink:"/docs/performance-optimizations"},next:{title:"Advanced concepts",permalink:"/docs/advanced-concepts"}},d={},c=[{value:"Using the <code>.map</code> method with <code>true</code> as the second argument",id:"using-the-map-method-with-true-as-the-second-argument",level:3},{value:"Using <code>create</code> with no arguments",id:"using-create-with-no-arguments",level:3}];function l(e){const n={blockquote:"blockquote",code:"code",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"xoid"})," offers basic support for ",(0,s.jsx)(n.strong,{children:"streams"}),". Streams are generally treated as a whole different concept than atoms. They're actually very close, and there's no need for a completely different library for them. ",(0,s.jsx)(n.strong,{children:"xoid"}),' thinks that streams can easily be a a "bonus feature" of an atomic state management library.']}),"\n",(0,s.jsx)(n.p,{children:"Our definition of a stream is the following:"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"stream"})," is an ",(0,s.jsx)(n.strong,{children:"atom"})," that ",(0,s.jsx)(n.strong,{children:"may not"})," have an immediate value."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"xoid"})," have a separate ",(0,s.jsx)(n.code,{children:"Stream"})," type along with the ",(0,s.jsx)(n.code,{children:"Atom"}),".\nStreams differ from atoms not only by types, but also in terms of the runtime behaviour."]}),"\n",(0,s.jsxs)(n.p,{children:["There are two ways to produce a stream in ",(0,s.jsx)(n.strong,{children:"xoid"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Using the ",(0,s.jsx)(n.code,{children:".map"})," method with ",(0,s.jsx)(n.code,{children:"true"})," as the second argument"]}),"\n",(0,s.jsxs)(n.li,{children:["Using ",(0,s.jsx)(n.code,{children:"create"})," with no arguments"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"using-the-map-method-with-true-as-the-second-argument",children:["Using the ",(0,s.jsx)(n.code,{children:".map"})," method with ",(0,s.jsx)(n.code,{children:"true"})," as the second argument"]}),"\n",(0,s.jsx)(n.p,{children:"Imagine we're setting up a basic counter, and we're deriving another counter that takes only the odd values from the first.\nWe can set this up in the following way:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const $counter = create(0)\nconst $odd = $counter.map((s) => s % 2 ? s : undefined, true) \n// Type of `$odd` would be `Stream<number>`\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"true"}),' in the second argument means "filter out falsy values" here.\nIf we didn\'t use this overload of ',(0,s.jsx)(n.code,{children:".map"}),", we would end up with a ",(0,s.jsx)(n.code,{children:"Atom<number | undefined>"}),".\nHowever, we would lose the following benefits:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const $doubleOdd = $odd.map((value) => value * 2)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, the type of ",(0,s.jsx)(n.code,{children:"value"})," is always a ",(0,s.jsx)(n.code,{children:"number"}),". If we were working with a ",(0,s.jsx)(n.code,{children:"Atom<number | undefined>"})," instead of a ",(0,s.jsx)(n.code,{children:"Stream<number>"}),", ",(0,s.jsx)(n.code,{children:"value"})," would also be ",(0,s.jsx)(n.code,{children:"number | undefined"})," and our code would be slightly more verbose to cover those cases."]}),"\n",(0,s.jsxs)(n.h3,{id:"using-create-with-no-arguments",children:["Using ",(0,s.jsx)(n.code,{children:"create"})," with no arguments"]}),"\n",(0,s.jsxs)(n.p,{children:["When no arguments are used, ",(0,s.jsx)(n.code,{children:"create"})," function produces a ",(0,s.jsx)(n.code,{children:"Stream"})," instead of an ",(0,s.jsx)(n.code,{children:"Atom"}),". Let's assume we're creating a ",(0,s.jsx)(n.code,{children:"$clickStream"})," and a ",(0,s.jsx)(n.code,{children:"$clickAtom"})," like the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import create from 'xoid'\n\nconst $clickStream = create<MouseEvent>() // Stream<MouseEvent>\nconst $clickAtom = create<MouseEvent | undefined>(undefined) // Atom<MouseEvent | undefined>\n\n// Imagine we're going to satisfy the internal value of these atoms later as:\nwindow.addEventListener('click', $clickStream.set)\nwindow.addEventListener('click', $clickAtom.set)\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Note that in JavaScript, calling a function with no arguments can be different than calling it with ",(0,s.jsx)(n.code,{children:"undefined"}),", if the internal implementation of the function makes use of the ",(0,s.jsx)(n.code,{children:"arguments.length"})," builtin. ",(0,s.jsx)(n.strong,{children:"xoid"})," makes use of exactly that."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Let's look at the similarities and differences between ",(0,s.jsx)(n.code,{children:"$clickStream"})," and ",(0,s.jsx)(n.code,{children:"$clickAtom"}),".\nFirst of all, their ",(0,s.jsx)(n.code,{children:".value"})," getter types are the same."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"$clickStream.value // MouseEvent | undefined\n$clickAtom.value // MouseEvent | undefined\n"})}),"\n",(0,s.jsxs)(n.p,{children:["However, there's a difference in ",(0,s.jsx)(n.code,{children:".set"})," method's types. This applies for ",(0,s.jsx)(n.code,{children:".update"})," as well."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"$clickStream.set // (value: MouseEvent) => void\n$clickAtom.set // (value: MouseEvent | undefined) => void\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A stream's key feature is the behavior of its ",(0,s.jsx)(n.code,{children:".map"})," and ",(0,s.jsx)(n.code,{children:".focus"})," methods.\nFirst, let's look at the ",(0,s.jsx)(n.code,{children:".map"})," method's types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"$clickStream.map((value) => { /* `value` has the `MouseEvent` type */ })\n$clickAtom.map((value) => { /* `value` has the `MouseEvent | undefined` type */ })\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As you can see, even though ",(0,s.jsx)(n.code,{children:"$clickStream"})," starts off ",(0,s.jsx)(n.code,{children:"undefined"})," as its internal value, we do not run into any ",(0,s.jsx)(n.code,{children:"undefined"})," type inside the ",(0,s.jsx)(n.code,{children:".map"})," method callback. This can be beneficial, because now you can chain multiple ",(0,s.jsx)(n.code,{children:".map"})," methods without caring about the ",(0,s.jsx)(n.code,{children:"undefined"})," states."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const double = (value: number) => value * 2\n\nconst $doubleX = clickStream\n  .map((event) => event.clientX)\n  .map(double)\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Lastly, here's the difference of the two, from the ",(0,s.jsx)(n.code,{children:"index.d.ts"})," file of ",(0,s.jsx)(n.strong,{children:"xoid"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export type Atom<T> = {\n  value: T\n  set(state: T): void\n  update(fn: (state: T) => T): void\n  subscribe(fn: (state: T, prevState: T) => unknown): () => void\n  watch(fn: (state: T, prevState: T) => unknown): () => void\n  focus<U>(fn: (state: T) => U): Atom<U>\n  focus<U extends keyof T>(key: U): Atom<T[U]>\n  map<U>(fn: (state: T, prevState: T) => U): Atom<U>\n  map<U>(fn: (state: T, prevState: T) => U, filterOutFalsyValues: true): Stream<Truthy<U>>\n}\n\nexport type Stream<T> = {\n  value: T | undefined\n  set(state: T): void\n  update(fn: (state: T | undefined) => T): void\n  subscribe(fn: (state: T, prevState: T | undefined) => unknown): () => void\n  watch(fn: (state: T | undefined, prevState: T | undefined) => unknown): () => void\n  focus<U>(fn: (state: T) => U): Stream<U>\n  focus<U extends keyof T>(key: U): Stream<T[U]>\n  map<U>(fn: (state: T, prevState: T | undefined) => U): Stream<U>\n  map<U>(\n    fn: (state: T, prevState: T | undefined) => U,\n    filterOutFalsyValues: true\n  ): Stream<Truthy<U>>\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Observe that the few major differences are the ",(0,s.jsx)(n.code,{children:".value"})," getter and bunch of ",(0,s.jsx)(n.code,{children:"prevState"}),"s."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>o});var s=t(7294);const a={},r=s.createContext(a);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);