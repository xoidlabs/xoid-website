"use strict";(self.webpackChunkxoid_website=self.webpackChunkxoid_website||[]).push([[885],{8454:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var s=n(5893),o=n(1151);const r={id:"use-setup",title:"useSetup"},c=void 0,i={id:"framework-integrations/use-setup",title:"useSetup",description:"import { useSetup } from '@xoid/react'",source:"@site/main/docs/framework-integrations/use-setup.md",sourceDirName:"framework-integrations",slug:"/framework-integrations/use-setup",permalink:"/docs/framework-integrations/use-setup",draft:!1,unlisted:!1,editUrl:"https://github.com/xoidlabs/xoid/blob/main/docs/framework-integrations/use-setup.md",tags:[],version:"current",lastUpdatedAt:1696936626,formattedLastUpdatedAt:"Oct 10, 2023",frontMatter:{id:"use-setup",title:"useSetup"},sidebar:"docs",previous:{title:"useAtom",permalink:"/docs/framework-integrations/use-atom"},next:{title:"Using context correctly",permalink:"/docs/recipes-react/using-context-correctly"}},a={},l=[{value:"Basic usage",id:"basic-usage",level:2},{value:"Importance of <code>useSetup</code> for React users",id:"importance-of-usesetup-for-react-users",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:"import { useSetup } from '@xoid/react'"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:"import { useSetup } from '@xoid/svelte'"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:"import { useSetup } from '@xoid/vue'"})}),"\n",(0,s.jsx)(t.h2,{id:"basic-usage",children:"Basic usage"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import { create } from 'xoid'\nimport { useSetup } from '@xoid/react'\n\n// inside a component\nconst $num = useSetup(() => create(5))\n"})}),"\n",(0,s.jsxs)(t.p,{children:["When a second argument is provided, it'll be available in the callback argument ",(0,s.jsx)(t.strong,{children:"as a reactive atom"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import { subscribe, use } from 'xoid'\nimport { useSetup } from '@xoid/react'\n\nconst App = (props: Props) => {\n  useSetup(($props) => {// `$props` has the type: Atom<Props>\n    $props.focus(s => s.something).subscribe(console.log)\n  }, props)\n  ...\n}\n"})}),"\n",(0,s.jsxs)(t.h2,{id:"importance-of-usesetup-for-react-users",children:["Importance of ",(0,s.jsx)(t.code,{children:"useSetup"})," for React users"]}),"\n",(0,s.jsx)(t.p,{children:"While Vue and Svelte chooses a static closure as the component mental model, React chooses a render cycle. Although a render cycle might look like a real closure, it's not. Some people may find it more comfortable, but it brings some difficulties to the table:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:'The runtime relies on the call order of hooks. This implies a strict "rules of hooks" to the user.'}),"\n",(0,s.jsxs)(t.li,{children:["The API surface has to increase. There comes hooks like ",(0,s.jsx)(t.code,{children:"useCallback"}),", ",(0,s.jsx)(t.code,{children:"useMemo"}),", ",(0,s.jsx)(t.code,{children:"useRef"})," just to persist variables."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Vue, Svelte, and more other frameworks on the other hand, use a real closure instead of a render cycle. They never need abstractions such as ",(0,s.jsx)(t.code,{children:"useCallback"}),", ",(0,s.jsx)(t.code,{children:"useMemo"}),", ",(0,s.jsx)(t.code,{children:"useRef"}),", nor they need a strict rules of hooks. ",(0,s.jsx)(t.strong,{children:"xoid"})," aims to bring the same to React."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import { useSetup } from '@xoid/react'\nimport { effect } from 'xoid/setup'\n\nconst App = (props: Props) => {\n  useSetup(() => {\n    const callback = () => { ... }\n\n    effect(() => {\n      window.addEventListener('resize', callback)\n      window.addEventListener('orientationchange', callback)\n\n      return () => {\n        window.removeEventListener('resize', callback)\n        window.removeEventListener('orientationchange', callback)\n      }\n    })\n  })\n  ...\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["You can call ",(0,s.jsx)(t.code,{children:"effect"})," multiple times, or conditionally. It'll connect to the same ",(0,s.jsx)(t.code,{children:"useEffect"})," call."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import { useSetup } from '@xoid/react'\nimport { effect } from 'xoid/setup'\n\nconst App = (props: Props) => {\n  useSetup(() => {\n    const callback = () => { ... }\n\n    effect(() => {\n      window.addEventListener('resize', callback)\n      return () => window.removeEventListener('resize', callback)\n    })\n\n    effect(() => {\n      window.addEventListener('orientationchange', callback)\n      return () => window.removeEventListener('orientationchange', callback)\n    })\n  })\n  ...\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Same applies for ",(0,s.jsx)(t.code,{children:"inject"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import { useSetup } from '@xoid/react'\nimport { inject } from 'xoid/setup'\nimport { ThemeSymbol } from './some-module'\n\nconst App = (props: Props) => {\n  useSetup(() => {\n    const theme = inject(ThemeSymbol)\n    // do something with the theme\n  })\n  ...\n}\n"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"useSetup"})," is actually more suitable than ",(0,s.jsx)(t.code,{children:"React.useMemo"})," to create values ",(0,s.jsx)(t.strong,{children:"exactly once"}),". According to ",(0,s.jsx)(t.a,{href:"https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily",children:"React docs"}),', "You may rely on useMemo as a performance optimization, not as a semantic guarantee. In the future, React may choose to \u201cforget\u201d some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components.". ',(0,s.jsx)(t.code,{children:"useSetup"})," hook is based on ",(0,s.jsx)(t.code,{children:"useRef"}),", thus it's guaranteed to run the callback exactly ",(0,s.jsx)(t.strong,{children:"once"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["Warning: ",(0,s.jsx)(t.code,{children:"@xoid/react"}),"'s way of implementing ",(0,s.jsx)(t.code,{children:"inject"})," relies on React internals that ",(0,s.jsx)(t.em,{children:"MIGHT"})," change in the future. This works properly since the React version 16 to the latest version 18 as of now, however if you choose to not use it, we would like to assure you that it has no runtime effect when it's not called. You can see the implementation ",(0,s.jsx)(t.a,{href:"https://github.com/xoidlabs/xoid/tree/master/packages/react/src/index.tsx",children:"here"}),". It's known that ",(0,s.jsx)(t.code,{children:"react-relay"})," uses the same internal, and it's even supported by ",(0,s.jsx)(t.code,{children:"preact/compat"}),". So it's likely there to stay, or at least an equivalent mechanism looks like is going to be supported in the next Fiber versions."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>c});var s=n(7294);const o={},r=s.createContext(o);function c(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);