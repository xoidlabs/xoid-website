"use strict";(self.webpackChunkxoid_website=self.webpackChunkxoid_website||[]).push([[995],{6161:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>l,frontMatter:()=>c,metadata:()=>i,toc:()=>d});var s=t(5893),r=t(1151);const c={id:"using-reducers",title:"Using reducers"},o=void 0,i={id:"recipes/using-reducers",title:"Using reducers",description:"xoid doesn't need reducers, but if you prefer to use them, or if you're moving away from Redux, but want to reuse your existing reducers, you can easily do that with xoid.",source:"@site/main/docs/recipes/using-reducers.md",sourceDirName:"recipes",slug:"/recipes/using-reducers",permalink:"/docs/recipes/using-reducers",draft:!1,unlisted:!1,editUrl:"https://github.com/xoidlabs/xoid/blob/main/docs/recipes/using-reducers.md",tags:[],version:"current",lastUpdatedAt:1673200693,formattedLastUpdatedAt:"Jan 8, 2023",frontMatter:{id:"using-reducers",title:"Using reducers"},sidebar:"docs",previous:{title:"Using immer",permalink:"/docs/recipes/using-immer"},next:{title:"Using in an existing Redux App",permalink:"/docs/recipes/redux-interop"}},a={},d=[];function u(e){const n={a:"a",code:"code",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"xoid"})," doesn't need reducers, but if you prefer to use them, or if you're moving away from Redux, but want to reuse your existing reducers, you can easily do that with ",(0,s.jsx)(n.strong,{children:"xoid"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The following function can be used to create a Redux-like atom."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const createStore = (reducer, state) => {\n  const atom = create(state)\n  const dispatch = (action) => atom.update((s) => reducer(s, action))\n  return { atom, dispatch }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's take this simple reducer:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const types = { increase: "INCREASE", decrease: "DECREASE" }\n\nconst counterReducer = (state, { type, by }) => {\n  switch (type) {\n    case types.increase: return {\n      ...state,\n      count: state.count + by \n    }\n    case types.decrease: return {\n      ...state,\n      count: state.count - by\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { atom, dispatch } = createStore({ count: 0 }, counterReducer)\n\ndispatch({ type: types.increase, by: 1 })\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Connecting existing reducers to ",(0,s.jsx)(n.strong,{children:"xoid"})," can be beneficial, especially if you're planning to gradually refactor your reducers. The above reducer can be simplified into to the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const CounterModel = (state) => create(state, (atom) => {\n  const $count = atom.focus('count')\n  return {\n    increment: (by) => $count.update(s => s + by),\n    decrement: (by) => $count.update(s => s - by),\n  }\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To see another demonstration with a more dramatic refactor, you can check ",(0,s.jsx)(n.a,{href:"nested-state",children:"Working with nested state"})]}),"\n",(0,s.jsxs)(n.p,{children:["Related: ",(0,s.jsx)(n.a,{href:"redux-interop",children:"Using in an existing Redux App"})]})]})}function l(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>o});var s=t(7294);const r={},c=s.createContext(r);function o(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);